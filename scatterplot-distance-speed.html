<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Activity Scatter Plot + Map</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
	<script src="https://cdn.jsdelivr.net/npm/luxon@3/build/global/luxon.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-luxon@1"></script>

	<link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
<script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>

<link rel="stylesheet" href="https://unpkg.com/leaflet.fullscreen/Control.FullScreen.css" />
<script src="https://unpkg.com/leaflet.fullscreen/Control.FullScreen.js"></script>

  <style>
    body { font-family: sans-serif; margin: auto; padding: 2rem; max-width: 1400px}
    #drop-area {
      width: 100%; height: 150px; border: 2px dashed #aaa;
      display: flex; align-items: center; justify-content: center;
      flex-direction: column;
      margin-bottom: 20px;
      cursor: pointer;
    }
    #drop-area:hover { background: #f9f9f9; }
    #fileInput { display: none; }
    #map { width: 100%; height: 600px; margin-top: 20px; }
    #detailChart { margin-top: 20px; }
    button { padding: 1px 5px; font-size: 14px; cursor: pointer; }
		#activityTable th {
  cursor: pointer;
  position: relative;
  user-select: none;
}

#activityTable th:hover {
  background-color: #f2f2f2;
}

#activityTable th.sorted-asc::after {
  content: " ▲";
  position: absolute;
  right: 8px;
}

#activityTable th.sorted-desc::after {
  content: " ▼";
  position: absolute;
  right: 8px;
}
	.highlighted-row {
  background-color: #ffe5e5;
}

  </style>
</head>
<body>
<h1>Scatterplot</h1>
<div id="drop-area">
  Drag & Drop TCX or GPX files here
  <button id="uploadBtn">Or select files manually</button>
  <input type="file" id="fileInput" multiple accept=".tcx,.gpx">
</div>
<p>.fit files can be converted to .txc using this <a href="https://github.com/zuiraito/rangi.dev/blob/main/convert_fit_to_gpx.sh">script</a>.</p>
<br><br>
<canvas id="scatterChart" width="900" height="500"></canvas>
<br><br>
<canvas id="detailChart" width="900" height="400"></canvas>
<button id="zoomIn">+</button>
<button id="zoomOut">-</button>
<button id="resetZoom">Reset Zoom</button>
<div id="map"></div>
<br><br>
<canvas id="timeChart" width="900" height="400"></canvas>
<h2>Uploaded Activities</h2>

<div style="margin-bottom: 1em;">
  <label>
    Date from:
    <input type="date" id="dateMin">
  </label>
  <label>
    to:
    <input type="date" id="dateMax">
  </label>
  <label style="margin-left: 2em;">
    Distance from (km):
    <input type="number" id="distMin" step="0.1">
  </label>
  <label>
    to:
    <input type="number" id="distMax" step="0.1">
  </label>
  <button onclick="filterTable()">Apply</button>
  <button onclick="resetFilters()">Reset</button>
</div>

<table id="activityTable" border="1" cellpadding="6" cellspacing="0" style="border-collapse: collapse; width: 100%; text-align: left; cursor: pointer;">
  <thead>
    <tr>
      <th onclick="sortTable(0)">Name</th>
      <th onclick="sortTable(1)">Date</th>
      <th onclick="sortTable(2)">Distance (km)</th>
      <th onclick="sortTable(3)">Time</th>
      <th onclick="sortTable(4)">Avg Speed (km/h)</th>
      <th onclick="sortTable(5)">Max Speed (km/h)</th>
      <th onclick="sortTable(6)">Avg HR</th>
      <th onclick="sortTable(7)">Max HR</th>
    	<th onclick="sortTable(8)">Total Ascent (m)</th>
    	<th onclick="sortTable(9)">Total Descent (m)</th>
      <th>View</th>
    </tr>
  </thead>
  <tbody></tbody>
</table>


<script>
// --- Map setup ---
	// Define base tile layers
const osm = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
  attribution: '© OpenStreetMap contributors'
});

const topo = L.tileLayer('https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png', {
  attribution: '© OpenTopoMap contributors'
});

const cartoDark = L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png', {
  attribution: '© CARTO',
  subdomains: 'abcd',
  maxZoom: 19
});

const cartoLight = L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png', {
  attribution: '© CARTO',
  subdomains: 'abcd',
  maxZoom: 19
});


const esriSat = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
  attribution: 'Tiles © Esri'
});
	
// --- White background layer ---
const whiteBg = L.tileLayer('', {
  attribution: ''
});


// Initialize map with default layer
const map = L.map('map', {
  fullscreenControl: true,
  layers: [cartoLight]  // start with OSM
}).setView([48, 11], 5);
// Add layer switcher control
const baseMaps = {
  "OpenStreetMap": osm,
  "Topo Map": topo,
  "Carto Light": cartoLight,
  "Carto Dark": cartoDark,
  "Esri Satellite": esriSat,
  "No Map": whiteBg,
};
L.control.layers(baseMaps).addTo(map);
let trackLayers = [];   // keep references to every polyline (all blue by default)
let hoverMarker = null;

let dragStartIndex = null;
let dragEndIndex = null;
function zoomChart(chart, factor) {
  const scale = chart.scales.x;
  let min = scale.min !== null ? scale.min : scale._userMin ?? scale.min;
  let max = scale.max !== null ? scale.max : scale._userMax ?? scale.max;

  // Fallback if auto scale
  if (min === null || max === null) {
    min = scale.min;
    max = scale.max;
  }

  const range = max - min;
  const center = (max + min) / 2;
  const newRange = range * factor;

  chart.options.scales.x.min = center - newRange / 2;
  chart.options.scales.x.max = center + newRange / 2;
  chart.update();
}

document.getElementById('zoomIn').addEventListener('click', () => {
  [detailChart, timeChart].forEach(c => zoomChart(c, 0.8)); // zoom in (20%)
});

document.getElementById('zoomOut').addEventListener('click', () => {
  [detailChart, timeChart].forEach(c => zoomChart(c, 1.25)); // zoom out (25%)
});
document.getElementById('resetZoom').addEventListener('click', () => {
  [detailChart, timeChart].forEach(c => {
    c.options.scales.x.min = null;
    c.options.scales.x.max = null;
    c.options.scales.y.min = null;
    c.options.scales.y.max = null;
    c.update();
  });
	// zoom out to show selected track
  if (activeScatterIndex != null) {
    const selectedPoint = scatterChart.data.datasets[0].data[activeScatterIndex];
    if (selectedPoint && selectedPoint.track && selectedPoint.track.length) {
			map.flyToBounds(selectedPoint.track, {
  padding: [5, 5], // optional padding around the bounds
  duration: .5      // seconds for animation
});

    }
  }
});

// --- Haversine ---
function haversine(lat1, lon1, lat2, lon2) {
  const R = 6371e3;
  const φ1 = lat1 * Math.PI/180, φ2 = lat2 * Math.PI/180;
  const dφ = (lat2-lat1) * Math.PI/180;
  const dλ = (lon2-lon1) * Math.PI/180;
  const a = Math.sin(dφ/2)**2 + Math.cos(φ1)*Math.cos(φ2)*Math.sin(dλ/2)**2;
  return R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
}

// --- Average moving speed helpers ---
function averageMovingSpeedTcx(xml) {
  const speedEls = xml.querySelectorAll("Trackpoint Extensions TPX Speed");
  let sum = 0, count = 0;
  speedEls.forEach(el => {
    const speed = parseFloat(el.textContent);
    if (!isNaN(speed)) { sum += speed; count++; }
  });
  return count > 0 ? (sum / count) * 3.6 : null;
}
function averageMovingSpeedGpx(xml) {
  const pts = xml.querySelectorAll("trkpt");
  let dist = 0, movingTime = 0;
  let last = null;
  pts.forEach(pt => {
    const lat = parseFloat(pt.getAttribute("lat"));
    const lon = parseFloat(pt.getAttribute("lon"));
    const timeEl = pt.querySelector("time");
    if (timeEl) {
      const time = new Date(timeEl.textContent).getTime();
      if (last) {
        const d = haversine(lat, lon, last.lat, last.lon);
        const dt = (time - last.time) / 1000;
        if (dt > 0 && d/dt > 0.5) {
          dist += d;
          movingTime += dt;
        }
      }
      last = { lat, lon, time };
    }
  });
  return movingTime > 0 ? (dist / movingTime) * 3.6 : null;
}

// --- HR color gradient ---
function hrToColor(hr, minHR = 100, maxHR = 180) {
  if (hr == null) return "gray";
  const t = Math.max(0, Math.min(1, (hr - minHR)/(maxHR - minHR)));
  if (t < 0.33) {
    const p = t/0.33;
    return `rgb(0, ${Math.round(255*p)}, ${Math.round(255*(1-p))})`;
  } else if (t < 0.66) {
    const p = (t-0.33)/0.33;
    return `rgb(${Math.round(255*p)}, 255, 0)`;
  } else {
    const p = (t-0.66)/0.34;
    return `rgb(255, ${Math.round(165*(1-p))}, 0)`;
  }
}

// --- Shared hover state ---
let activeHoverIndex = null;

// --- Vertical line plugin (for both charts) ---
const verticalLinePlugin = {
  id: 'verticalLine',
  afterDatasetsDraw(chart) {
    if (activeHoverIndex == null) return;
    const ctx = chart.ctx;
    const dataset = chart.data.datasets[0];
    if (!dataset || !dataset.data || !dataset.data[activeHoverIndex]) return;
    const x = chart.scales.x.getPixelForValue(dataset.data[activeHoverIndex].x);

    ctx.save();
    ctx.beginPath();
    ctx.moveTo(x, chart.chartArea.top);
    ctx.lineTo(x, chart.chartArea.bottom);
    ctx.lineWidth = 1.5;
    ctx.strokeStyle = 'red';
    ctx.stroke();
    ctx.restore();
  }
};
// --- Hover function for charts ---
function handleHover(evt, chart) {
  if (activeScatterIndex == null) return;

  const xScale = chart.scales.x;
  // Get the X value at the mouse position
  const xValue = xScale.getValueForPixel(evt.offsetX);

  // Find the nearest point based on X only
  const dataset = chart.data.datasets[0];
  let closestIndex = 0;
  let minDist = Infinity;
  dataset.data.forEach((pt, i) => {
    const dist = Math.abs(pt.x - xValue);
    if (dist < minDist) {
      minDist = dist;
      closestIndex = i;
    }
  });

  activeHoverIndex = closestIndex;

  // Update map marker based on the closest X
  const p = scatterChart.data.datasets[0].data[activeScatterIndex];
  if (p && p.track) {
    const trackPoint = p.track[activeHoverIndex] || p.track[p.track.length-1];
    if (hoverMarker) hoverMarker.remove();
    hoverMarker = L.circleMarker(trackPoint, { radius: 6, color: 'red', fill: true }).addTo(map);
  }

  detailChart.update('none');
  timeChart.update('none');
}

// --- Add hover listeners ---
document.getElementById('detailChart').addEventListener('mousemove', evt => handleHover(evt, detailChart));
document.getElementById('timeChart').addEventListener('mousemove', evt => handleHover(evt, timeChart));
document.getElementById('detailChart').addEventListener('mouseleave', () => {
  activeHoverIndex = null;
  if (hoverMarker) { hoverMarker.remove(); hoverMarker = null; }
  detailChart.update('none');
  timeChart.update('none');
});
document.getElementById('timeChart').addEventListener('mouseleave', () => {
  activeHoverIndex = null;
  if (hoverMarker) { hoverMarker.remove(); hoverMarker = null; }
  detailChart.update('none');
  timeChart.update('none');
});

const detailAnnotationsPlugin = {
  id: 'detailAnnotations',
  afterDatasetsDraw(chart) {
    const datasets = chart.data.datasets;
    if (!datasets || datasets.length === 0) return;
    if (!datasets[0].data || datasets[0].data.length === 0) return;

    const ctx = chart.ctx;
    let maxSpeed = -Infinity, maxHR = -Infinity, maxEle = -Infinity, minEle = Infinity;
    let maxSpeedIndex = 0, maxHRIndex = 0, maxEleIndex = 0, minEleIndex = 0;

    datasets.forEach(ds => {
      if (!ds.data) return;
      ds.data.forEach((pt, i) => {
        if (ds.label === 'Speed (km/h)' && pt.y != null && pt.y > maxSpeed) {
          maxSpeed = pt.y; maxSpeedIndex = i;
        }
        if (ds.label === 'Heart Rate (bpm)' && pt.y != null && pt.y > maxHR) {
          maxHR = pt.y; maxHRIndex = i;
        }
        if (ds.label === 'Elevation (m)' && pt.y != null) {
          if (pt.y > maxEle) { maxEle = pt.y; maxEleIndex = i; }
          if (pt.y < minEle) { minEle = pt.y; minEleIndex = i; }
        }
      });
    });

    ctx.save();
    ctx.fillStyle = 'black';
    ctx.font = '12px sans-serif';
    ctx.textAlign = 'left';

    if (maxSpeed > -Infinity) {
      const x = chart.scales.x.getPixelForValue(datasets[0].data[maxSpeedIndex].x);
      const y = chart.scales.y.getPixelForValue(maxSpeed);
      ctx.fillText(`Max Speed: ${maxSpeed.toFixed(1)} km/h`, x + 5, y - 5);
    }
    if (maxHR > -Infinity && datasets[1] && datasets[1].data[maxHRIndex]) {
      const x = chart.scales.x.getPixelForValue(datasets[1].data[maxHRIndex].x);
      const y = chart.scales.y2.getPixelForValue(maxHR);
      ctx.fillText(`Max HR: ${maxHR.toFixed(0)} bpm`, x + 5, y - 5);
    }
    if (maxEle > -Infinity && datasets[2] && datasets[2].data[maxEleIndex]) {
      const x = chart.scales.x.getPixelForValue(datasets[2].data[maxEleIndex].x);
      const y = chart.scales.y1.getPixelForValue(maxEle);
      ctx.fillText(`Max Elev: ${maxEle.toFixed(1)} m`, x + 5, y - 5);
    }
    if (minEle < Infinity && datasets[2] && datasets[2].data[minEleIndex]) {
      const x = chart.scales.x.getPixelForValue(datasets[2].data[minEleIndex].x);
      const y = chart.scales.y1.getPixelForValue(minEle);
      ctx.fillText(`Min Elev: ${minEle.toFixed(1)} m`, x + 5, y + 15);
    }

    ctx.restore();
  }
};
// --- Detail chart (full config) ---
const detailCtx = document.getElementById('detailChart').getContext('2d');
let detailChart = new Chart(detailCtx, {
  type: 'line',
  data: { labels: [], datasets: [] },
  options: {
    responsive: true,
    interaction: { mode: 'index', intersect: false },
    stacked: false,
    plugins: {
      title: { display: true, text: 'Distance Plot' },
      legend: { display: true, labels: { usePointStyle: true, pointStyle: 'line' } }
    },
    scales: {
      x: { type: 'linear', title: { display: true, text: 'Distance (km)' } },
      y: { title: { display: true, text: 'Speed (km/h)' } },
      y1: { title: { display: true, text: 'Elevation (m)' }, position: 'right', grid: { drawOnChartArea: false } },
      y2: { title: { display: true, text: 'Heart Rate (bpm)' } }
    }
  },
  plugins: [verticalLinePlugin, detailAnnotationsPlugin]
});

// --- Time chart ---
const timeCtx = document.getElementById('timeChart').getContext('2d');
let timeChart = new Chart(timeCtx, {
  type: 'line',
  data: { labels: [], datasets: [] },
  options: {
    responsive: true,
    interaction: { mode: 'index', intersect: false },
    stacked: false,
    plugins: {
      title: { display: true, text: 'Time Plot' },
      legend: { display: true, labels: { usePointStyle: true, pointStyle: 'line' } }
    },
    scales: {
			x: {
  type: 'time',
  time: {
    unit: 'minute',
    tooltipFormat: 'HH:mm:ss',      // tooltip uses 24h format
    displayFormats: {
      hour: 'HH:mm',                // axis labels for hours
      minute: 'HH:mm'               // axis labels for minutes
    }
  },
  title: { display: true, text: 'Time' }
},
      y: { title: { display: true, text: 'Speed (km/h)' } },
      y1: { title: { display: true, text: 'Elevation (m)' }, position: 'right', grid: { drawOnChartArea: false } },
      y2: { title: { display: true, text: 'Heart Rate (bpm)' } }
    }
  },

  plugins: [verticalLinePlugin, detailAnnotationsPlugin]
});



// --- Scatter chart (overview) ---
const scatterCtx = document.getElementById('scatterChart').getContext('2d');
let activeScatterIndex = null;

let scatterChart = new Chart(scatterCtx, {
  type: 'scatter',
  data: { datasets: [{ label: 'Activities', data: [], backgroundColor: [] }] },
  options: {

    scales: {
      x: {
    type: 'logarithmic',
    title: { display: true, text: 'Distance (km, log)' },
    ticks: {
      callback: (val) => {
        const num = Number(val);
        return Number.isInteger(num) ? num.toString() : num.toString();
      }
    }
  },
      y: { title: { display: true, text: 'Avg Moving Speed (km/h)' } }
    },
    plugins: {
      tooltip: {
        callbacks: {
          label: ctx => {
            const p = ctx.raw;
            return `${p.file} – ${p.x.toFixed(1)} km @ ${p.y.toFixed(1)} km/h, HR: ${p.hr ?? "n/a"}`;
          }
        }
      }
    },
    onClick: (evt, elems) => {
      if (!elems.length) return;
      const clickedIndex = elems[0].index;
      activeScatterIndex = clickedIndex;
      const p = scatterChart.data.datasets[0].data[clickedIndex];
      if (!p || !p.track) return;
			// Reset style for all scatter points
scatterChart.data.datasets[0].pointBorderColor =
  scatterChart.data.datasets[0].data.map(() => "transparent");
scatterChart.data.datasets[0].pointBorderWidth =
  scatterChart.data.datasets[0].data.map(() => 0);

// Highlight clicked point with red outline
scatterChart.data.datasets[0].pointBorderColor[clickedIndex] = "red";
scatterChart.data.datasets[0].pointBorderWidth[clickedIndex] = 3;

scatterChart.update();
let chartDragStart = null;

function getNearestIndexByX(chart, evt) {
  const xScale = chart.scales.x;
  const xValue = xScale.getValueForPixel(evt.offsetX);
  const dataset = chart.data.datasets[0];

  let closestIndex = 0;
  let minDist = Infinity;
  dataset.data.forEach((pt, i) => {
    const dist = Math.abs(pt.x - xValue);
    if (dist < minDist) {
      minDist = dist;
      closestIndex = i;
    }
  });
  return closestIndex;
}

function handleChartDragStart(evt, chart) {
  chartDragStart = getNearestIndexByX(chart, evt);
}

function handleChartDragEnd(evt, chart) {
  if (chartDragStart == null) return;
  const endIndex = getNearestIndexByX(chart, evt);

  const start = Math.min(chartDragStart, endIndex);
  const end = Math.max(chartDragStart, endIndex);

  // --- Update both charts ---
  [detailChart, timeChart].forEach(c => {
    const subsetX = c.data.datasets[0].data.slice(start, end + 1).map(p => p.x);
    c.options.scales.x.min = Math.min(...subsetX);
    c.options.scales.x.max = Math.max(...subsetX);

    const subsetY = c.data.datasets[0].data.slice(start, end + 1).map(p => p.y).filter(v => v != null);
    if (subsetY.length > 0) {
      c.options.scales.y.min = Math.min(...subsetY);
      c.options.scales.y.max = Math.max(...subsetY);
    }
    c.update();
  });

  // --- Zoom map ---
  if (activeScatterIndex != null) {
    const track = scatterChart.data.datasets[0].data[activeScatterIndex].track;
    if (track) {
      const subsetTrack = track.slice(start, end + 1);
      if (subsetTrack.length) map.fitBounds(subsetTrack);
    }
  }

  chartDragStart = null;
}


			// Add listeners to both charts
[detailChart, timeChart].forEach(chart => {
  const canvas = chart.canvas;
  canvas.addEventListener('mousedown', evt => handleChartDragStart(evt, chart));
  canvas.addEventListener('mouseup', evt => handleChartDragEnd(evt, chart));
});


      // Reset style for all layers to blue
      trackLayers.forEach(layer => layer.setStyle({ color: "blue", weight: 3, opacity: 0.4 }));

      // Highlight clicked layer (we stored the layer reference on the point)
      if (p.layer) {
        p.layer.setStyle({ color: "red", weight: 3, opacity: 1 });
        p.layer.bringToFront();
        map.fitBounds(p.layer.getBounds());
      }

      document.getElementById("detailChart").scrollIntoView({ behavior: "smooth" });

      // Build arrays for the detail chart (reuse the XML inside p.xml for accurate per-point values)
      const distArr = [], hrArr = [], speedArr = [], elevArr = [];
      let totalDist = 0, last = null;

      if (p.file.toLowerCase().endsWith(".tcx")) {
        p.xml.querySelectorAll("Trackpoint").forEach(tp => {
          const latEl = tp.querySelector("LatitudeDegrees");
          const lonEl = tp.querySelector("LongitudeDegrees");
          if (latEl && lonEl) {
            const lat = parseFloat(latEl.textContent);
            const lon = parseFloat(lonEl.textContent);
            if (last) totalDist += haversine(lat, lon, last.lat, last.lon) / 1000;
            last = { lat, lon };
            distArr.push(totalDist);
            const hrEl = tp.querySelector("HeartRateBpm Value");
            const spdEl = tp.querySelector("Extensions TPX Speed");
            const eleEl = tp.querySelector("AltitudeMeters");
            hrArr.push(hrEl ? parseFloat(hrEl.textContent) : null);
            speedArr.push(spdEl ? parseFloat(spdEl.textContent) * 3.6 : null);
            elevArr.push(eleEl ? parseFloat(eleEl.textContent) : null);
          }
        });
      } else if (p.file.toLowerCase().endsWith(".gpx")) {
        p.xml.querySelectorAll("trkpt").forEach(pt => {
          const lat = parseFloat(pt.getAttribute("lat"));
          const lon = parseFloat(pt.getAttribute("lon"));
          if (!isNaN(lat) && !isNaN(lon)) {
            if (last) totalDist += haversine(lat, lon, last.lat, last.lon) / 1000;
            last = { lat, lon };
            distArr.push(totalDist);
            const eleEl = pt.querySelector("ele");
            hrArr.push(null);
            speedArr.push(null);
            elevArr.push(eleEl ? parseFloat(eleEl.textContent) : null);
          }
        });
      }

      // Update detail chart datasets
      detailChart.data.labels = distArr;
			const avgSpeed = speedArr.reduce((sum, v) => sum + (v || 0), 0) / speedArr.filter(v => v != null).length;

      detailChart.data.datasets = [
				{
  label: 'Speed (km/h)',
  data: distArr.map((d,i) => ({ x: d, y: speedArr[i] })),
  yAxisID: 'y',
  borderColor: 'rgba(80, 80, 255, 1)',
					borderWidth: 1,
  backgroundColor: 'rgba(80, 80, 255, 0.5)', // fill color
  fill: {
    target: { value: avgSpeed }  // use precomputed average
  },
  pointRadius: 0
        },
        {
          label: 'Heart Rate (bpm)',
          data: distArr.map((d, i) => ({ x: d, y: hrArr[i] })),
          yAxisID: 'y2',
          borderColor: 'rgba(255, 80, 80, 1)',
					borderWidth: 1,
          backgroundColor: 'rgba(255, 80, 80, 0.5)',
          fill: false,
          pointRadius: 0,
          hidden: true
        },
  {
    label: 'Elevation (m)',
    data: distArr.map((d, i) => ({ x: d, y: elevArr[i] })),
    yAxisID: 'y1',
    borderColor: 'rgba(0, 55, 0, 0.2)',
    backgroundColor: 'rgba(0, 80, 0, 0.5)',
    fill: true,
    pointRadius: 0
  }
      ];
			// Compute min/max for elevation and enforce at least 20m range
const eleData = elevArr.filter(v => v != null);
if (eleData.length > 0) {
  let minEle = Math.min(...eleData) - 2; // 2m below actual min
  let maxEle = Math.max(...eleData);
  const minRange = 40;

  if (maxEle - minEle < minRange) {
    // Expand the max to ensure at least 20m range
    maxEle = minEle + minRange;
  }

  detailChart.options.scales.y1.min = minEle;
  detailChart.options.scales.y1.max = maxEle;
}

detailChart.update();
const timeArr = [];

if (p.file.toLowerCase().endsWith(".tcx")) {
  let lastTime = null;
  p.xml.querySelectorAll("Trackpoint").forEach(tp => {
    const timeEl = tp.querySelector("Time");
    if (timeEl) {
      const t = new Date(timeEl.textContent);
      timeArr.push(t);
    } else {
      timeArr.push(null);
    }
  });
} else if (p.file.toLowerCase().endsWith(".gpx")) {
  p.xml.querySelectorAll("trkpt").forEach(pt => {
    const timeEl = pt.querySelector("time");
    timeArr.push(timeEl ? new Date(timeEl.textContent) : null);
  });
}

timeChart.data.labels = timeArr;
timeChart.data.datasets = [
  {
    label: 'Speed (km/h)',
    data: timeArr.map((t,i)=>({ x: t, y: speedArr[i] })),
    yAxisID: 'y',
    borderColor: 'rgba(80,80,255,1)',
    borderWidth: 1,
    backgroundColor: 'rgba(80,80,255,0.5)',
    fill: { target: { value: avgSpeed } },
    pointRadius: 0
  },
  {
    label: 'Heart Rate (bpm)',
    data: timeArr.map((t,i)=>({ x: t, y: hrArr[i] })),
    yAxisID: 'y2',
    borderColor: 'rgba(255,80,80,1)',
    borderWidth: 1,
    backgroundColor: 'rgba(255,80,80,0.5)',
    fill: false,
    pointRadius: 0,
    hidden: true
  },
  {
    label: 'Elevation (m)',
    data: timeArr.map((t,i)=>({ x: t, y: elevArr[i] })),
    yAxisID: 'y1',
    borderColor: 'rgba(0,55,0,0.2)',
    backgroundColor: 'rgba(0,80,0,0.5)',
    fill: true,
    pointRadius: 0
  }
];

// Sync min/max elevation as for detail chart
if (eleData.length > 0) {
  let minEle = Math.min(...eleData) - 2;
  let maxEle = Math.max(...eleData);
  if (maxEle - minEle < 40) maxEle = minEle + 40;
  timeChart.options.scales.y1.min = minEle;
  timeChart.options.scales.y1.max = maxEle;
}

// Highlight clicked layer (track) and row
if (p.layer) {
  p.layer.setStyle({ color: "red", weight: 3, opacity: 1 });
  p.layer.bringToFront();
  map.fitBounds(p.layer.getBounds());
}

// Highlight the corresponding table row
highlightRow(p.file);


timeChart.update();



    }
  }
});

// --- Hover → vertical line & map marker (on detail chart) ---
document.getElementById('detailChart').addEventListener('mousemove', evt => {
  const points = detailChart.getElementsAtEventForMode(evt, 'index', { intersect: false }, true);

  if (points.length && activeScatterIndex != null) {
    const idx = points[0].index;
    const p = scatterChart.data.datasets[0].data[activeScatterIndex];
    if (p && p.track) {
      const trackPoint = p.track[idx] || p.track[p.track.length-1];
      if (hoverMarker) { hoverMarker.remove(); hoverMarker = null; }
      hoverMarker = L.circleMarker(trackPoint, { radius: 6, color: 'red', fill: true }).addTo(map);
    }
  } else {
    if (hoverMarker) { hoverMarker.remove(); hoverMarker = null; }
  }
});
document.getElementById('timeChart').addEventListener('mousemove', evt => {
  const points = timeChart.getElementsAtEventForMode(evt, 'index', { intersect: false }, true);
  if (points.length && activeScatterIndex != null) {
    const idx = points[0].index;
    const p = scatterChart.data.datasets[0].data[activeScatterIndex];
    if (p && p.track) {
      const trackPoint = p.track[idx] || p.track[p.track.length-1];
      if (hoverMarker) { hoverMarker.remove(); hoverMarker = null; }
      hoverMarker = L.circleMarker(trackPoint, { radius: 6, color: 'red', fill: true }).addTo(map);
    }
  } else {
    if (hoverMarker) { hoverMarker.remove(); hoverMarker = null; }
  }
});

document.getElementById('detailChart').addEventListener('mouseleave', () => {
  if (hoverMarker) { hoverMarker.remove(); hoverMarker = null; }
});

// --- File loading ---
function handleFiles(files) {
  for (const file of files) {
    const reader = new FileReader();
    reader.onload = () => {
      const parser = new DOMParser();
      const xml = parser.parseFromString(reader.result, "application/xml");
      // If parsing failed, exit early (prevents undefined xml structure)
      if (xml.querySelector && xml.querySelector('parsererror')) {
        console.error('XML parse error for', file.name);
        return;
      }

      let distanceKm = null, avgMovingSpeed = null, hr = null, maxSpeed = null, track = [];


if (file.name.toLowerCase().endsWith(".tcx")) {
  const distanceEl = xml.querySelector("DistanceMeters");
  distanceKm = distanceEl ? parseFloat(distanceEl.textContent)/1000 : null;
  avgMovingSpeed = averageMovingSpeedTcx(xml);

  const hrEl = xml.querySelector("AverageHeartRateBpm Value");
  hr = hrEl ? parseFloat(hrEl.textContent) : null;

  xml.querySelectorAll("Trackpoint").forEach(tp => {
    const latEl = tp.querySelector("LatitudeDegrees");
    const lonEl = tp.querySelector("LongitudeDegrees");
    const spdEl = tp.querySelector("Extensions TPX Speed");

    if (latEl && lonEl) {
      track.push([parseFloat(latEl.textContent), parseFloat(lonEl.textContent)]);
    }

    if (spdEl) {
      const s = parseFloat(spdEl.textContent) * 3.6; // convert to km/h
      if (!isNaN(s)) {
        if (maxSpeed === null || s > maxSpeed) maxSpeed = s;
      }
    }
  });
} else if (file.name.toLowerCase().endsWith(".gpx")) {
  let totalDist = 0, last = null;
  xml.querySelectorAll("trkpt").forEach(pt => {
    const lat = parseFloat(pt.getAttribute("lat"));
    const lon = parseFloat(pt.getAttribute("lon"));
    if (!isNaN(lat) && !isNaN(lon)) {
      track.push([lat, lon]);
      if (last) totalDist += haversine(lat, lon, last.lat, last.lon);
      last = { lat, lon };
    }
  });
  distanceKm = totalDist/1000;
  avgMovingSpeed = averageMovingSpeedGpx(xml);
  // GPX usually doesn’t have per-point speed, so leave maxSpeed = null
}
let totalAscent = 0;
let totalDescent = 0;
let lastEle = null;

xml.querySelectorAll("trkpt, Trackpoint").forEach(pt => {
  const eleEl = pt.querySelector("ele") || pt.querySelector("AltitudeMeters");
  if (eleEl) {
    const ele = parseFloat(eleEl.textContent);
    if (!isNaN(ele)) {
      if (lastEle !== null) {
        const diff = ele - lastEle;
        if (diff > 0) totalAscent += diff;
        else totalDescent += Math.abs(diff);
      }
      lastEle = ele;
    }
  }
});


// save it in your scatter point
const point = {
  x: distanceKm,
  y: avgMovingSpeed,
  hr,
  file: file.name,
  track,
  xml,
  layer: null,
  maxSpeed,
  totalAscent,
  totalDescent
};
;


      if (distanceKm && avgMovingSpeed) {
        const color = hrToColor(hr);
        // Create the scatter-point object and keep the layer reference on it
        const point = { x: distanceKm, y: avgMovingSpeed, hr, file: file.name, track, xml, layer: null };
        scatterChart.data.datasets[0].data.push(point);
        scatterChart.data.datasets[0].backgroundColor.push(color);
        scatterChart.update();

        // add blue polyline to map and store reference on the point
				const layer = L.polyline(track, {
  color: "blue",
  weight: 4,       // a bit wider
  opacity: 0.4     // more transparent
}).addTo(map);

trackLayers.push(layer);
point.layer = layer;

// make the polyline clickable
layer.on("click", () => {
  const idx = scatterChart.data.datasets[0].data.indexOf(point);
  if (idx !== -1) {
    // simulate scatter chart click
    scatterChart.options.onClick(null, [{ datasetIndex: 0, index: idx }]);
  }
});

      }
// --- Extract stats for the table ---
let date = null, duration = null, avgHR = null, maxHR = null;

// Try to extract time/date
if (file.name.toLowerCase().endsWith(".tcx")) {
  const startTimeEl = xml.querySelector("Id, Time");
  if (startTimeEl) date = new Date(startTimeEl.textContent);
  const totalTimeEl = xml.querySelector("TotalTimeSeconds");
  if (totalTimeEl) duration = parseFloat(totalTimeEl.textContent);
  const avgHrEl = xml.querySelector("AverageHeartRateBpm Value");
  if (avgHrEl) avgHR = parseFloat(avgHrEl.textContent);
  const maxHrEl = xml.querySelector("MaximumHeartRateBpm Value");
  if (maxHrEl) maxHR = parseFloat(maxHrEl.textContent);
  const maxSpdEl = xml.querySelector("MaximumSpeed");
  if (maxSpdEl) maxSpeed = parseFloat(maxSpdEl.textContent) * 3.6;
} else if (file.name.toLowerCase().endsWith(".gpx")) {
  const firstPt = xml.querySelector("trkpt time");
  if (firstPt) date = new Date(firstPt.textContent);
  // You could calculate duration by last - first timestamp
  const times = [...xml.querySelectorAll("trkpt time")].map(t=>new Date(t.textContent).getTime());
  if (times.length > 1) duration = (Math.max(...times)-Math.min(...times))/1000;
  // HR and max speed usually missing in GPX, leave null
}

// Format time hh:mm:ss
function formatDuration(sec) {
  if (!sec) return "n/a";
  const h = Math.floor(sec/3600);
  const m = Math.floor((sec%3600)/60);
  const s = Math.floor(sec%60);
  return [h,m,s].map(v=>String(v).padStart(2,"0")).join(":");
}

// Add row to table
const tbody = document.querySelector("#activityTable tbody");
const tr = document.createElement("tr");
tr.innerHTML = `
  <td>${file.name}</td>
  <td>${date ? date.toLocaleString() : "n/a"}</td>
  <td>${distanceKm.toFixed(2)}</td>
  <td>${formatDuration(duration)}</td>
  <td>${avgMovingSpeed?.toFixed(1) ?? "n/a"}</td>
	<td>${point.maxSpeed ? point.maxSpeed.toFixed(1) : "n/a"}</td>
  <td>${avgHR ?? "n/a"}</td>
  <td>${maxHR ?? "n/a"}</td>
  <td>${point.totalAscent.toFixed(0)}</td>
  <td>${point.totalDescent.toFixed(0)}</td>

  <td><button onclick="viewActivity('${file.name}')">View</button></td>
`;
tbody.appendChild(tr);

// Store a mapping for "view" button
if (!window.activityMap) window.activityMap = {};
window.activityMap[file.name] = scatterChart.data.datasets[0].data[scatterChart.data.datasets[0].data.length-1];

    };

    reader.readAsText(file);
  }
}
let highlightedRow = null;
function highlightRow(filename) {
  const tbody = document.querySelector("#activityTable tbody");
  for (let row of tbody.rows) {
    if (row.cells[0].innerText === filename) {
      row.classList.add("highlighted-row");

   //   row.scrollIntoView({ behavior: "smooth", block: "center" });  // scroll down to the selected row of the table
    } else {
      row.classList.remove("highlighted-row");
    }
  }
}

function viewActivity(filename) {
  const point = window.activityMap[filename];
  if (!point) return;
  const idx = scatterChart.data.datasets[0].data.indexOf(point);
  if (idx !== -1) {
    scatterChart.options.onClick(null, [{ datasetIndex: 0, index: idx }]);
    highlightRow(filename); // <-- Highlight row here too
    document.getElementById("detailChart").scrollIntoView({ behavior: "smooth" });
  }
}


// Drag & drop + manual upload handling
const dropArea = document.getElementById('drop-area');
dropArea.addEventListener('dragover', e => e.preventDefault());
dropArea.addEventListener('drop', e => { e.preventDefault(); handleFiles(e.dataTransfer.files); });

const fileInput = document.getElementById('fileInput');
const uploadBtn = document.getElementById('uploadBtn');
uploadBtn.addEventListener('click', () => fileInput.click());
fileInput.addEventListener('change', () => handleFiles(fileInput.files));

// Table logic
let sortDirection = {}; // remember direction per column
function sortTable(colIndex) {
  const table = document.getElementById("activityTable");
  const tbody = table.tBodies[0];
  const rows = Array.from(tbody.rows);

  const ths = table.tHead.rows[0].cells;

  // Reset old arrows
  for (let th of ths) th.classList.remove("sorted-asc", "sorted-desc");

  const dir = sortDirection[colIndex] === "asc" ? "desc" : "asc";
  sortDirection[colIndex] = dir;

rows.sort((a, b) => {
  let A = a.cells[colIndex].innerText.trim();
  let B = b.cells[colIndex].innerText.trim();

  // Convert to number if possible
  const numA = parseFloat(A.replace(",", "."));
  const numB = parseFloat(B.replace(",", "."));

  // Determine if values are numbers or n/a
  const isNumA = !isNaN(numA);
  const isNumB = !isNaN(numB);

  if (isNumA && isNumB) {
    return dir === "asc" ? numA - numB : numB - numA;
  } else if (!isNumA && A === "n/a") {
    // Put n/a at bottom
    return dir === "asc" ? 1 : 1;
  } else if (!isNumB && B === "n/a") {
    return dir === "asc" ? -1 : -1;
  } else {
    // fallback to string compare
    return dir === "asc" ? A.localeCompare(B) : B.localeCompare(A);
  }
});


  rows.forEach(r => tbody.appendChild(r));

  // Add arrow to current column
  ths[colIndex].classList.add(dir === "asc" ? "sorted-asc" : "sorted-desc");
}

function filterTable() {
  const dateMin = document.getElementById("dateMin").value ? new Date(document.getElementById("dateMin").value) : null;
  const dateMax = document.getElementById("dateMax").value ? new Date(document.getElementById("dateMax").value) : null;
  const distMin = parseFloat(document.getElementById("distMin").value);
  const distMax = parseFloat(document.getElementById("distMax").value);

  const tbody = document.querySelector("#activityTable tbody");
  for (let row of tbody.rows) {
    const dateText = row.cells[1].innerText.trim();
    const distText = row.cells[2].innerText.trim();

    const date = Date.parse(dateText) ? new Date(dateText) : null;
    const dist = parseFloat(distText);

    let visible = true;

    if (dateMin && date && date < dateMin) visible = false;
    if (dateMax && date && date > dateMax) visible = false;
    if (!isNaN(distMin) && !isNaN(dist) && dist < distMin) visible = false;
    if (!isNaN(distMax) && !isNaN(dist) && dist > distMax) visible = false;

    row.style.display = visible ? "" : "none";
  }
}

function resetFilters() {
  document.getElementById("dateMin").value = "";
  document.getElementById("dateMax").value = "";
  document.getElementById("distMin").value = "";
  document.getElementById("distMax").value = "";
  filterTable();
}

</script>
</body>
</html>

